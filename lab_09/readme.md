# Разбор кода

Код представлен на языке C с вкраплениями ассемблерных инструкций, использующих набор команд AVX (Advanced Vector
Extensions). Этот код изменяет яркость изображения, представленного в формате BMP.

## Содержание файла `main.c`

1. **Подключение заголовочных файлов:**
   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <stdint.h>
   #include <immintrin.h>
   #include <math.h>
   #include "bmp.h"
   ```
   Эти заголовочные файлы необходимы для работы с функциями ввода-вывода, динамической памяти, математическими
   операциями и функциями AVX. В модуле `bmp` реализуются загрузка bmp изображения в формат массива double от 0 до 1 и
   сохранение такого массива обратно в формат bmp изображения.

2. **Ассемблерная функция для изменения яркости:**
   ```c
   void change_brightness_avx(double *data, int width, int height, int channels, double brightness) {
       int size = width * height * channels;
       __m256d factor = _mm256_set1_pd(brightness);
       __m256d factor_white = _mm256_set1_pd(1.0);

       for (int i = 0; i < size; i += 4) {
           asm (
               "vmovupd (%0), %%ymm0;"      // Загружаем 4 double в ymm0
               "vmulpd %2, %%ymm0, %%ymm1;" // Умножаем на фактор
               "vminpd %3, %%ymm1, %%ymm1;" // Ограничиваем значения 1.0
               "vmovupd %%ymm1, (%1);"      // Записываем результат обратно в память
               :
               : "r"(data + i), "r"(data + i), "x"(factor), "x"(factor_white)
               : "ymm0", "ymm1"
           );
       }
   }
   ```
    - `vmovupd (%0), %%ymm0;`: Загружает 4 числа типа `double` из памяти (адрес `%0`) в регистр `ymm0`.
    - `vmulpd %2, %%ymm0, %%ymm1;`: Умножает содержимое регистра `ymm0` на `factor` (яркость) и сохраняет результат
      в `ymm1`.
    - `vminpd %3, %%ymm1, %%ymm1;`: Ограничивает значения в `ymm1` максимальным значением (1.0).
    - `vmovupd %%ymm1, (%1);`: Сохраняет результат из регистра `ymm1` обратно в память (адрес `%1`).

3. **Функция `main`:**
   ```c
   int main() {
       int width = 128;  // ширина изображения
       int height = 128; // высота изображения
       int channels = 3; // число каналов (RGB)
       double brightness = 1.5; // коэффициент изменения яркости

       double *image = bmp_load_image("input.bmp", &width, &height, &channels);
       if (!image) {
           fprintf(stderr, "Failed to load input image\n");
           return EXIT_FAILURE;
       }

       change_brightness_avx(image, width, height, channels, brightness);

       if (bmp_save_image("output.bmp", image, width, height, channels) != 0) {
           fprintf(stderr, "Failed to save output image\n");
           free(image);
           return EXIT_FAILURE;
       }

       free(image);

       return EXIT_SUCCESS;
   }
   ```

## Пояснения к функциям AVX и используемым инструкциям

### Что такое AVX?

AVX (Advanced Vector Extensions) — это расширение набора команд x86, разработанное для повышения производительности при
обработке вычислений с плавающей запятой. AVX позволяет работать с регистром `ymm`, который вмещает 256 бит данных. Это
позволяет обрабатывать 4 числа типа `double` одновременно, что значительно ускоряет выполнение вычислений по сравнению с
последовательной обработкой.

### Основные команды AVX, используемые в коде:

- `vmovupd`: Загружает или сохраняет значения с плавающей запятой двойной точности (double-precision floating-point)
  в/из памяти.
- `vmulpd`: Умножает значения с плавающей запятой двойной точности.
- `vminpd`: Выбирает минимальные значения из двух наборов данных с плавающей запятой двойной точности.

## Принцип работы функции `change_brightness_avx`

1. **Подготовка данных:**
    - Вычисляется общий размер изображения в пикселях с учётом каналов (RGB).
    - Создаются AVX-векторы для коэффициента яркости и ограничения (максимального значения 1.0).

2. **Основной цикл:**
    - В цикле обрабатываются 4 пикселя за итерацию.
    - Значения пикселей загружаются в AVX-регистр.
    - Значения умножаются на коэффициент яркости.
    - Значения ограничиваются максимальным значением 1.0.
    - Результаты сохраняются обратно в память.

3. **Загрузка и сохранение изображения:**
    - Используются вспомогательные функции для загрузки и сохранения BMP-файлов (`bmp_load_image` и `bmp_save_image`).

# Генерация изображений

Для удобной отладки приложения был написан скрипт на Python, который создает монотонное или градиентное изображение для
дальнейшей обработки. Чтобы он работал, нужно установить зависимости из `requirements.txt`.

Если вдруг когда-то понадобится, Python библиотека `pillow-simd` умеет использовать ассемблер для быстрой обработки
изображений, поддерживает SSE и AVX. `pillow-simd` полностью соответствует `pillow` и может ее заменить без
необходимости корректировать что-либо. Работает только под x86-64.
