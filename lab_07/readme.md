# Ассемблерная вставка

Ассемблерная вставка (inline assembly) позволяет включать в программу на языке высокого уровня, таком как C или C++,
фрагменты кода на языке ассемблера. Это может быть полезно для оптимизации, работы с конкретными аппаратными ресурсами
или выполнения операций, которые сложно выразить на языке высокого уровня.
Рассмотрим подробнее, как это работает на **64-разрядной системе** под **MacOS**.

### Основные соглашения

Для ассемблерной вставки в GCC/Clang используются следующие соглашения:

1. **Секция входных операндов**: перечисляются переменные на языке C, которые будут использоваться в ассемблерном коде.
2. **Секция выходных операндов**: перечисляются переменные на языке C, которые будут обновляться ассемблерным кодом.
3. **Секция изменяемых регистров**: перечисляются регистры, которые изменяются ассемблерным кодом (опционально).

### Синтаксис ассемблерной вставки

```c
__asm__ (
    "assembly code"
    : output operands  /* выходные операнды */
    : input operands   /* входные операнды */
    : clobbers         /* изменяемые регистры (опционально) */
);
```

### Пример: Функция сложения

Разберем пример функции `add_numbers_ins`, которая складывает два числа, используя ассемблерную вставку:

```c
long add_numbers_ins(long a, long b) {
    long result;

    __asm__ (
            "addq %%rbx, %%rax;"  // Ассемблерный код: сложение значений в регистрах rbx и rax
            : "=a" (result)       // Выходной операнд: результат сохраняется в регистр rax и затем в переменную result
            : "a" (a), "b" (b)    // Входные операнды: a в регистре rax, b в регистре rbx
    );

    return result;
}
```

### Объяснение кода

1. **Ассемблерный код**:
    - `"addq %%rbx, %%rax;"`: команда `addq` складывает значение регистра `rbx` с значением регистра `rax` и сохраняет
      результат в `rax`.

2. **Выходной операнд**:
    - `=a (result)`: `=a` означает, что результат операции будет сохранен в регистре `rax`, а затем перемещен в
      переменную `result`.

3. **Входные операнды**:
    - `"a" (a)`: переменная `a` передается в регистр `rax`.
    - `"b" (b)`: переменная `b` передается в регистр `rbx`.

### Передача указателей на строки и константных указателей

Для передачи указателей в ассемблерной вставке нужно просто указать тип указателя в секции входных операндов.
Например, для строки (указатель на `char`) или константного указателя (`const char *`):

```c
void example_function(const char *str) {
    __asm__ (
            "movq %0, %%rdi;"  // Копируем указатель на строку в регистр rdi (входной регистр для первого аргумента функции в ABI x86-64)
            : /* нет выходных операндов */
            : "r" (str)        // str передается в любой доступный регистр, который выбирает компилятор
            : "%rdi"           // rdi используется и изменяется в этом блоке кода
    );
}
```

### Нюансы и советы

1. **Использование регистров**: Будьте осторожны с выбором регистров, чтобы избежать конфликтов. Если ваш ассемблерный
   код использует конкретные регистры, объявите их в секции `clobbers`, чтобы компилятор знал, что эти регистры будут
   изменены.

2. **Компиляторские оптимизации**: Ассемблерная вставка может нарушить оптимизации компилятора, поэтому рекомендуется
   использовать ее только в критически важных местах, где она действительно необходима.

3. **Конвенции вызовов**: На x86-64 системы (включая MacOS) аргументы функции передаются через регистры: первый аргумент
   в `rdi`, второй в `rsi`, третий в `rdx`, четвертый в `rcx`, пятый в `r8`, шестой в `r9`. Остальные аргументы
   передаются через стек.

Использование ассемблерной вставки требует внимательности и понимания архитектуры процессора, но при правильном
использовании может значительно повысить производительность критичных участков кода.

# Интеграция ассемблерных файлов c C

Для интеграции ассемблерного кода с кодом на языке C, нужно создать функцию в ассемблере,
которая будет вызываться из программы на C. Затем скомпилировать оба файла и слинковать их вместе.

### 1. Ассемблерный код

Создайте файл с ассемблерным кодом, например `add.asm`:

```asm
section .data

section .text
    global _add_numbers

_add_numbers:
    ; Входные параметры:
    ; rdi - первое число
    ; rsi - второе число
    ; Возвращаемое значение:
    ; rax - результат сложения

    ; Выполнение сложения
    mov rax, rdi
    add rax, rsi

    ; Завершение функции
    ret
```

### 2. Код на языке C

Создайте файл с кодом на языке C, например `main.c`:

```c
#include <stdio.h>

// Объявление ассемблерной функции
extern long add_numbers(long a, long b);

int main() {
    long num1 = 5;
    long num2 = 3;
    long result;

    result = add_numbers(num1, num2);

    printf("Result: %ld\n", result);
    return 0;
}
```

### 3. Компиляция и сборка

1. Компиляция ассемблерного кода в объектный файл:

    ```sh
    nasm -fmacho64 -o add.o strnmove.asm
    ```

2. Компиляция кода на языке C в объектный файл:

    ```sh
    clang -c -o main.o main.c
    ```

3. Сборка объектных файлов в исполняемый файл:

    ```sh
    clang -o main.exe main.o add.o
    ```

Для удобства можно использовать Make, подробнее ниже.

### 4. Запуск

Запустите исполняемый файл:

```sh
./main.exe
```

### Объяснение

1. **Ассемблерный код**:
    - **`global _add_numbers`**: Определяет функцию `_add_numbers` как глобальную, чтобы она могла быть вызвана из кода
      на языке C.
    - **`mov rax, rdi`**: Загружает значение первого параметра в регистр `rax`.
    - **`add rax, rsi`**: Складывает значение второго параметра с `rax`.
    - **`ret`**: Завершает функцию и возвращает результат в `rax`.

2. **Код на языке C**:
    - **`extern long add_numbers(long a, long b);`**: Объявляет ассемблерную функцию для использования в C.
    - **`result = add_numbers(num1, num2);`**: Вызывает ассемблерную функцию и сохраняет результат.

3. **Компиляция и сборка**:
    - `nasm -fmacho64 -o add.o add.asm`: Компилирует ассемблерный файл в объектный файл.
    - `clang -c -o main.o main.c`: Компилирует файл на языке C в объектный файл.
    - `clang -o main main.o add.o`: Линкует объектные файлы и создает исполняемый файл.

### Ошибки при линковке на MacOS

Иногда во время линковки могут возникать ошибки, указывающие на проблему с разрешением символов, определенных в
ассемблерном коде.
Это может быть связано с неправильным именованием символов или несовпадением имен.
На **macOS** символы могут требовать дополнительного подчеркивания при экспорте функций в коде на C.
Убедитесь, что функция **экспортируется с подчеркиванием перед именем**, так как компилятор C ожидает символ с
подчеркиванием.
**Код на языке C при этом вызывает функции без подчеркиваний**, так как компилятор автоматически добавляет их к именам
функций при вызове.

```asm
section .text
    global _add_numbers  ; здесь обязательно использовать _, чтобы соответствовать соглашениям именования символов на macOS

_add_numbers:  ; здесь обязательно использовать _, чтобы соответствовать соглашениям именования символов на macOS
    mov rax, rdi
    add rax, rsi
    ret
```

# Сборка Make

Для сборки подобных проектов часто удобно использовать систему Make. Вот пример Makefile, который собирает все файлы
на языке C и на ассемблере NASM и линкует их в один исполняемый файл main.exe:

```makefile
NASM_CC = nasm
NASM_CC_OPTIONS = -fmacho64

CC = clang
CC_OPTIONS = -c

NASM_SRCS = $(wildcard *.asm)
C_SRCS = $(wildcard *.c)

OUT = main.exe

all: link

comp_nasm:
	$(NASM_CC) $(NASM_CC_OPTIONS) $(NASM_SRCS)

comp_c:
	$(CC) $(CC_OPTIONS) $(C_SRCS)

link: comp_nasm comp_c
	$(CC) -o $(OUT) *.o

clean:
	$(RM) -f *.o $(OUT)
```

### Объяснение

1. **Цель `all`**: По умолчанию выполняет цель `link`, которая зависит от `comp_nasm` и `comp_c`.
2. **Цель `comp_nasm`**: Компилирует все ассемблерные файлы `*.asm` в объектные файлы `*.o`.
3. **Цель `comp_c`**: Компилирует все C-файлы `*.c` в объектные файлы `*.o`.
4. **Цель `link`**: Линкует все объектные файлы `*.o` в исполняемый файл `main.exe`.
5. **Цель `clean`**: Удаляет все объектные файлы и исполняемый файл.

### Использование

1. Сохраните `Makefile` в корневом каталоге проекта.
2. Для компиляции и линковки всех файлов выполните команду:

    ```sh
    make
    ```

3. Для удаления всех скомпилированных файлов выполните команду:

    ```sh
    make clean
    ```

Этот `Makefile` автоматизирует процесс сборки, упрощая компиляцию и линковку ассемблерного и C-кода.

# Разбор кода

Давайте подробно разберем код на C и NASM, чтобы понять его структуру и функциональность.

### main.c

Этот файл на C включает основную функцию программы, определяет длину строки (`my_strlen`) с использованием ассемблерного
блока и вызывает ассемблерную функцию `my_strnmove`.

#### 1. `my_strlen` функция

Эта функция вычисляет длину строки `str` с использованием ассемблера.

```c
long my_strlen(char *str) {
    long len;

    __asm__ (
        "movq %%rbx, %%rdi;"    // Кладем указатель на строку из bx в di
        "xor %%rcx, %%rcx;"
        "not %%rcx;"
        "xor %%rax, %%rax;"     // Будем сравнивать с нулем
        "repne scasb;"          // Ищем ax в строке по адресу di
        "movq %%rdi, %%rax;"    // Кладем конечное значение di в rax
        "subq %%rbx, %%rax;"    // Вычтем начальное значение указателя строки
        "dec %%rax;"            // Вычтем еще 1, так как di указывает на байт после нулевого символа
        : "=a" (len)            // Выходное значение (длина строки из ax)
        : "b" (str)             // Входное значение (указатель на строку в bx)
    );

    return len;
}
```

- **`movq %%rbx, %%rdi;`**: Копирует указатель строки из `rbx` в `rdi`.
- **`xor %%rcx, %%rcx; not %%rcx;`**: Устанавливает `rcx` в максимальное значение, чтобы искать по всей строке.
- **`xor %%rax, %%rax;`**: Обнуляет `rax`, так как будем искать нулевой символ.
- **`repne scasb;`**: Ищет байт нулевого значения (`0`) в строке.
- **`movq %%rdi, %%rax; subq %%rbx, %%rax; dec %%rax;`**: Вычисляет длину строки путем вычитания начального указателя из
  конечного и вычитания еще 1, так как `rdi` указывает на байт после нулевого символа.

#### 2. `main` функция

Основная функция программы, где происходит вызов `my_strlen` и `my_strnmove`.

```c
int main(void) {
    char s[] = "Hello World!";
    long len = my_strlen(s);
    printf("Strlen: %ld\n", len);

    char s2[50];
    my_strnmove(s2, s, len);
    printf("Strnmove: %s\n", s2);

    return EXIT_SUCCESS;
}
```

- **`my_strlen(s);`**: Вызывает функцию для вычисления длины строки `s`.
- **`my_strnmove(s2, s, len);`**: Вызывает ассемблерную функцию `my_strnmove` для копирования строки `s` в `s2`.

### strnmove.asm

Этот файл содержит ассемблерную реализацию функции `my_strnmove`.

```asm
section .text
    global _my_strnmove

_my_strnmove:
    ; Входные параметры:
    ; rdi - destptr
    ; rsi - srcptr
    ; rdx - num
    ; Выходные параметры:
    ; rax - destptr
    push rdi
    push rsi
    push rdx

    ; Если адреса назначения и источника равны, можно ничего не копировать
    cmp rdi, rsi
    je .done

    ; Если destptr > srcptr, то копируем с конца, чтобы избежать перезаписи данных
    mov rcx, rdx
    cmp rdi, rsi
    jb .forward_copy
    jmp .backward_copy

.backward_copy:
    ; Копирование с конца
    lea rsi, [rsi + rcx - 1]  ; Устанавливаем rsi на конец блока источника
    lea rdi, [rdi + rcx - 1]  ; Устанавливаем rdi на конец блока назначения
    std                       ; Устанавливаем направление копирования назад
    rep movsb                 ; Копируем байты
    cld                       ; Сбрасываем направление копирования

    jmp .done

.forward_copy:
    ; Копирование с начала
    cld                       ; Устанавливаем направление копирования вперед
    rep movsb                 ; Копируем байты

    jmp .done

.done:
    mov byte [rdi], 0         ; Добавляем \0 в конец строки

    pop rdx
    pop rsi
    pop rdi

    mov rax, rdi              ; rdi снова содержит destptr, возвращаем через rax

    ret
```

#### Основные этапы:

1. **`push rdi, rsi, rdx`**: Сохраняем регистры на стек.
2. **`cmp rdi, rsi`**: Сравниваем указатели назначения и источника. Если они равны, переходим к завершению.
3. **`mov rcx, rdx`**: Копируем количество байт для перемещения.
4. **Копирование назад**:
    - **`lea rsi, [rsi + rcx - 1]; lea rdi, [rdi + rcx - 1]`**: Устанавливаем указатели на конец блоков.
    - **`std`**: Устанавливаем направление копирования назад.
    - **`rep movsb`**: Копируем байты.
    - **`cld`**: Сбрасываем направление копирования.
5. **Копирование вперед**:
    - **`cld`**: Устанавливаем направление копирования вперед.
    - **`rep movsb`**: Копируем байты.
6. **`mov byte [rdi], 0`**: Добавляем нулевой символ в конец строки.
7. **`pop rdx, rsi, rdi`**: Восстанавливаем регистры.
8. **`mov rax, rdi`**: Возвращаем указатель назначения.
9. **`ret`**: Возвращаемся из функции.

### Итог

- **`my_strlen`**: Использует ассемблерный код для вычисления длины строки.
- **`my_strnmove`**: Ассемблерная функция для копирования строки с учетом возможного перекрытия областей памяти.
