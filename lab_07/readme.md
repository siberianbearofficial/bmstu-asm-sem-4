# Ассемблерная вставка

Ассемблерная вставка (inline assembly) позволяет включать в программу на языке высокого уровня, таком как C или C++,
фрагменты кода на языке ассемблера. Это может быть полезно для оптимизации, работы с конкретными аппаратными ресурсами
или выполнения операций, которые сложно выразить на языке высокого уровня.
Рассмотрим подробнее, как это работает на **64-разрядной системе** под **MacOS**.

### Основные соглашения

Для ассемблерной вставки в GCC/Clang используются следующие соглашения:

1. **Секция входных операндов**: перечисляются переменные на языке C, которые будут использоваться в ассемблерном коде.
2. **Секция выходных операндов**: перечисляются переменные на языке C, которые будут обновляться ассемблерным кодом.
3. **Секция изменяемых регистров**: перечисляются регистры, которые изменяются ассемблерным кодом (опционально).

### Синтаксис ассемблерной вставки

```c
__asm__ (
    "assembly code"
    : output operands  /* выходные операнды */
    : input operands   /* входные операнды */
    : clobbers         /* изменяемые регистры (опционально) */
);
```

### Пример: Функция сложения

Разберем пример функции `add_numbers_ins`, которая складывает два числа, используя ассемблерную вставку:

```c
long add_numbers_ins(long a, long b) {
    long result;

    __asm__ (
            "addq %%rbx, %%rax;"  // Ассемблерный код: сложение значений в регистрах rbx и rax
            : "=a" (result)       // Выходной операнд: результат сохраняется в регистр rax и затем в переменную result
            : "a" (a), "b" (b)    // Входные операнды: a в регистре rax, b в регистре rbx
    );

    return result;
}
```

### Объяснение кода

1. **Ассемблерный код**:
    - `"addq %%rbx, %%rax;"`: команда `addq` складывает значение регистра `rbx` с значением регистра `rax` и сохраняет
      результат в `rax`.

2. **Выходной операнд**:
    - `=a (result)`: `=a` означает, что результат операции будет сохранен в регистре `rax`, а затем перемещен в
      переменную `result`.

3. **Входные операнды**:
    - `"a" (a)`: переменная `a` передается в регистр `rax`.
    - `"b" (b)`: переменная `b` передается в регистр `rbx`.

### Передача указателей на строки и константных указателей

Для передачи указателей в ассемблерной вставке нужно просто указать тип указателя в секции входных операндов.
Например, для строки (указатель на `char`) или константного указателя (`const char *`):

```c
void example_function(const char *str) {
    __asm__ (
            "movq %0, %%rdi;"  // Копируем указатель на строку в регистр rdi (входной регистр для первого аргумента функции в ABI x86-64)
            : /* нет выходных операндов */
            : "r" (str)        // str передается в любой доступный регистр, который выбирает компилятор
            : "%rdi"           // rdi используется и изменяется в этом блоке кода
    );
}
```

### Нюансы и советы

1. **Использование регистров**: Будьте осторожны с выбором регистров, чтобы избежать конфликтов. Если ваш ассемблерный
   код использует конкретные регистры, объявите их в секции `clobbers`, чтобы компилятор знал, что эти регистры будут
   изменены.

2. **Компиляторские оптимизации**: Ассемблерная вставка может нарушить оптимизации компилятора, поэтому рекомендуется
   использовать ее только в критически важных местах, где она действительно необходима.

3. **Конвенции вызовов**: На x86-64 системы (включая MacOS) аргументы функции передаются через регистры: первый аргумент
   в `rdi`, второй в `rsi`, третий в `rdx`, четвертый в `rcx`, пятый в `r8`, шестой в `r9`. Остальные аргументы
   передаются через стек.

Использование ассемблерной вставки требует внимательности и понимания архитектуры процессора, но при правильном
использовании может значительно повысить производительность критичных участков кода.

# Интеграция ассемблерных файлов c C

Для интеграции ассемблерного кода с кодом на языке C, нужно создать функцию в ассемблере,
которая будет вызываться из программы на C. Затем скомпилировать оба файла и слинковать их вместе.

### 1. Ассемблерный код

Создайте файл с ассемблерным кодом, например `add.asm`:

```asm
section .data

section .text
    global _add_numbers

_add_numbers:
    ; Входные параметры:
    ; rdi - первое число
    ; rsi - второе число
    ; Возвращаемое значение:
    ; rax - результат сложения

    ; Выполнение сложения
    mov rax, rdi
    add rax, rsi

    ; Завершение функции
    ret
```

### 2. Код на языке C

Создайте файл с кодом на языке C, например `main.c`:

```c
#include <stdio.h>

// Объявление ассемблерной функции
extern long add_numbers(long a, long b);

int main() {
    long num1 = 5;
    long num2 = 3;
    long result;

    result = add_numbers(num1, num2);

    printf("Result: %ld\n", result);
    return 0;
}
```

### 3. Компиляция и сборка

1. Компиляция ассемблерного кода в объектный файл:

    ```sh
    nasm -fmacho64 -o add.o add.asm
    ```

2. Компиляция кода на языке C в объектный файл:

    ```sh
    clang -c -o main.o main.c
    ```

3. Сборка объектных файлов в исполняемый файл:

    ```sh
    clang -o main.exe main.o add.o
    ```

Для удобства можно использовать Make, подробнее ниже.

### 4. Запуск

Запустите исполняемый файл:

```sh
./main.exe
```

### Объяснение

1. **Ассемблерный код**:
    - **`global _add_numbers`**: Определяет функцию `_add_numbers` как глобальную, чтобы она могла быть вызвана из кода
      на языке C.
    - **`mov rax, rdi`**: Загружает значение первого параметра в регистр `rax`.
    - **`add rax, rsi`**: Складывает значение второго параметра с `rax`.
    - **`ret`**: Завершает функцию и возвращает результат в `rax`.

2. **Код на языке C**:
    - **`extern long add_numbers(long a, long b);`**: Объявляет ассемблерную функцию для использования в C.
    - **`result = add_numbers(num1, num2);`**: Вызывает ассемблерную функцию и сохраняет результат.

3. **Компиляция и сборка**:
    - `nasm -fmacho64 -o add.o add.asm`: Компилирует ассемблерный файл в объектный файл.
    - `clang -c -o main.o main.c`: Компилирует файл на языке C в объектный файл.
    - `clang -o main main.o add.o`: Линкует объектные файлы и создает исполняемый файл.

### Ошибки при линковке на MacOS

Иногда во время линковки могут возникать ошибки, указывающие на проблему с разрешением символов, определенных в
ассемблерном коде.
Это может быть связано с неправильным именованием символов или несовпадением имен.
На **macOS** символы могут требовать дополнительного подчеркивания при экспорте функций в коде на C.
Убедитесь, что функция **экспортируется с подчеркиванием перед именем**, так как компилятор C ожидает символ с
подчеркиванием.
**Код на языке C при этом вызывает функции без подчеркиваний**, так как компилятор автоматически добавляет их к именам
функций при вызове.

```asm
section .text
    global _add_numbers  ; здесь обязательно использовать _, чтобы соответствовать соглашениям именования символов на macOS

_add_numbers:  ; здесь обязательно использовать _, чтобы соответствовать соглашениям именования символов на macOS
    mov rax, rdi
    add rax, rsi
    ret
```

# Сборка Make

Для сборки подобных проектов часто удобно использовать систему Make. Вот пример Makefile, который собирает все файлы
на языке C и на ассемблере NASM и линкует их в один исполняемый файл main.exe:

```makefile
NASM_CC = nasm
NASM_CC_OPTIONS = -fmacho64

CC = clang
CC_OPTIONS = -c

NASM_SRCS = $(wildcard *.asm)
C_SRCS = $(wildcard *.c)

OUT = main.exe

all: link

comp_nasm:
	$(NASM_CC) $(NASM_CC_OPTIONS) $(NASM_SRCS)

comp_c:
	$(CC) $(CC_OPTIONS) $(C_SRCS)

link: comp_nasm comp_c
	$(CC) -o $(OUT) *.o

clean:
	$(RM) -f *.o $(OUT)
```

### Объяснение

1. **Цель `all`**: По умолчанию выполняет цель `link`, которая зависит от `comp_nasm` и `comp_c`.
2. **Цель `comp_nasm`**: Компилирует все ассемблерные файлы `*.asm` в объектные файлы `*.o`.
3. **Цель `comp_c`**: Компилирует все C-файлы `*.c` в объектные файлы `*.o`.
4. **Цель `link`**: Линкует все объектные файлы `*.o` в исполняемый файл `main.exe`.
5. **Цель `clean`**: Удаляет все объектные файлы и исполняемый файл.

### Использование

1. Сохраните `Makefile` в корневом каталоге проекта.
2. Для компиляции и линковки всех файлов выполните команду:

    ```sh
    make
    ```

3. Для удаления всех скомпилированных файлов выполните команду:

    ```sh
    make clean
    ```

Этот `Makefile` автоматизирует процесс сборки, упрощая компиляцию и линковку ассемблерного и C-кода.
