# Разбор кода

**Внимание!** Этот код разрабатывался под **Android, arm64**.
Репозиторий клонировался через **Termux**, затем выполнялась компиляция clang-ом. Запускался полученный исполняемый
файл.
Можно было создать полноценное приложение, используя [Android NDK](https://developer.android.com/ndk),
чтобы не использовать Termux, но это потребовало бы больше времени на разработку.

Рассмотрим подробно ассемблерные вставки в функциях `vector_product` и `my_strlen`, а также разберем используемые
инструкции ARM и их принцип работы.

## Ассемблерные вставки в `vector_product`

Функция `vector_product` вычисляет скалярное произведение двух векторов. Для ускорения вычислений используются SIMD
инструкции ARM (NEON).

### Ассемблерная вставка для основного цикла:

```asm
"ld1 {v0.2d}, [%[a]], #16;"
"ld1 {v1.2d}, [%[b]], #16;"
"fmul v2.2d, v0.2d, v1.2d;"
"faddp d0, v2.2d;"
"fadd %d[result], %d[result], d0;"
```

- **`ld1 {v0.2d}, [%[a]], #16;`**: загружает два элемента (2 x 64-битные значения, так как используется `v0.2d`) из
  массива `a` в векторный регистр `v0` и увеличивает указатель `a` на 16 байт (2 элемента по 8 байт).
- **`ld1 {v1.2d}, [%[b]], #16;`**: аналогично загружает два элемента из массива `b` в векторный регистр `v1` и
  увеличивает указатель `b`.
- **`fmul v2.2d, v0.2d, v1.2d;`**: умножает элементы векторов `v0` и `v1` и сохраняет результат в `v2`.
- **`faddp d0, v2.2d;`**: суммирует элементы вектора `v2` и сохраняет результат в скалярный регистр `d0`.
- **`fadd %d[result], %d[result], d0;`**: добавляет значение регистра `d0` к переменной `result`.

### Ассемблерная вставка для оставшегося элемента:

```asm
"ldr d0, [%[a]];"
"ldr d1, [%[b]];"
"fmul d2, d0, d1;"
"fadd %d[result], %d[result], d2;"
```

- **`ldr d0, [%[a]];`**: загружает один элемент (64-битное значение) из массива `a` в регистр `d0`.
- **`ldr d1, [%[b]];`**: аналогично загружает один элемент из массива `b` в регистр `d1`.
- **`fmul d2, d0, d1;`**: умножает значения в регистрах `d0` и `d1` и сохраняет результат в `d2`.
- **`fadd %d[result], %d[result], d2;`**: добавляет значение регистра `d2` к переменной `result`.

## Ассемблерная вставка в `my_strlen`

Функция `my_strlen` вычисляет длину строки. Здесь используется обычный набор инструкций ARM (не NEON).

```asm
"mov x0, %1;"
"mov x1, #0;"
"1:;"
"ldrb w2, [x0], #1;"
"cmp w2, #0;"
"add x1, x1, #1;"
"bne 1b;"
"sub x1, x1, #1;"
"mov %0, x1;"
```

- **`mov x0, %1;`**: копирует указатель на строку в регистр `x0`.
- **`mov x1, #0;`**: инициализирует счетчик длины строки в регистре `x1`.
- **`1:;`**: метка для начала цикла.
- **`ldrb w2, [x0], #1;`**: загружает байт по адресу `x0` в регистр `w2` и увеличивает `x0` на 1.
- **`cmp w2, #0;`**: сравнивает загруженный байт с нулем.
- **`add x1, x1, #1;`**: увеличивает счетчик длины строки.
- **`bne 1b;`**: если загруженный байт не нулевой, возвращается к метке `1`.
- **`sub x1, x1, #1;`**: вычитает 1 из счетчика длины строки (корректировка, так как цикл завершился на нулевом
  символе).
- **`mov %0, x1;`**: копирует значение счетчика длины строки в переменную результата.

# Основные инструкции ARM (NEON)

- **`ld1`**: загрузка данных в векторный регистр.
- **`fmul`**: умножение элементов векторных регистров.
- **`faddp`**: сложение пар элементов вектора и получение скалярного результата.
- **`ldr`**: загрузка данных в скалярный регистр.
- **`ldrb`**: загрузка байта в скалярный регистр.
- **`cmp`**: сравнение двух значений.
- **`add`**: сложение.
- **`sub`**: вычитание.
- **`mov`**: перемещение данных между регистрами.
- **`bne`**: безусловный переход, если предыдущая операция не установила флаг нуля.

# Принцип работы

- Векторные инструкции (NEON) используются для обработки нескольких элементов за одну инструкцию, что значительно
  ускоряет вычисления, особенно при работе с большими массивами данных.
- Обычные инструкции ARM используются для простых операций, таких как вычисление длины строки.
- Ассемблерные вставки позволяют интегрировать высокоэффективный машинный код непосредственно в C-программу, используя
  оптимальные инструкции для конкретной архитектуры процессора.

Эти методы позволяют добиться значительного прироста производительности по сравнению с чистым C-кодом, особенно в
вычислительно интенсивных задачах.
