# Разбор кода

Рассмотрим подробно код на языке ассемблера MASM и разберем, что для чего нужно и как работает каждая его часть.

### Сегменты данных и стек

```assembly
data1 SEGMENT 'DATA'
buffer db 11, 0, 11 DUP ('$')
data1 ENDS

data2 SEGMENT 'DATA'
result db 5 DUP (' '), '$'
data2 ENDS

stack SEGMENT STACK 'STACK'
db 10h DUP (?)
stack ENDS
```

1. **data1 SEGMENT 'DATA'**:
    - **buffer db 11, 0, 11 DUP ('$')**: Сегмент `data1` содержит буфер для ввода строки. Первые два байта используются для хранения длины строки и введенного количества символов. Затем следует 11 байтов для самой строки, которые инициализированы значением `$`.

2. **data2 SEGMENT 'DATA'**:
    - **result db 5 DUP (' '), '$'**: Сегмент `data2` содержит буфер для результата. Он инициализирован пятью пробелами и символом `$`, что используется как маркер конца строки.

3. **stack SEGMENT STACK 'STACK'**:
    - **db 10h DUP (?)**: Сегмент стека, инициализированный размером 16 байт.

### Процедуры

#### read_buffer
```assembly
read_buffer proc
    ; читаем строку
    mov ah, 0Ah
    lea dx, buffer
    int 21h

    ; выводим перенос строки
    mov ah, 02h
    mov dl, 0Ah
    int 21h

    ret
read_buffer endp
```
Процедура `read_buffer` выполняет ввод строки:
- `mov ah, 0Ah` и `lea dx, buffer`: Используется функция DOS `0Ah` для ввода строки, адрес буфера загружается в `dx`.
- `int 21h`: Вызов DOS-прерывания для ввода строки.
- `mov ah, 02h`, `mov dl, 0Ah`, `int 21h`: Вывод символа новой строки (ASCII 0Ah).

#### print_result
```assembly
print_result proc
    ; выводим строку
    mov ah, 09h
    lea dx, result
    int 21h

    ret
print_result endp
```
Процедура `print_result` выводит строку:
- `mov ah, 09h` и `lea dx, result`: Используется функция DOS `09h` для вывода строки, адрес строки загружается в `dx`.
- `int 21h`: Вызов DOS-прерывания для вывода строки.

#### copy_even_symbols
```assembly
copy_even_symbols proc
    ; si - индекс в буфере, di - индекс в результирующей строке
    mov si, offset buffer + 2  ; в первых двух байтах ожидаемое и фактическое количества символов
    mov di, offset result

    ; будем перебирать не больше 9 символов
    mov cx, 9
    next_char:
        ; читаем символ по адресу ds:si в al (si инкрементируется)
        lodsb

        ; если индекс нечетный, идем в copy_char
        test si, 1
        jnz copy_char

        ; проходим по каждому символу
        loop next_char

        ; после цикла выходим
        jmp done

    copy_char:
        ; пишем символ из al по адресу es:di (di инкрементируется)
        stosb

        ; возвращаемся в цикл
        loop next_char

    done:
        ret
copy_even_symbols endp
```
Процедура `copy_even_symbols` копирует символы с четных позиций:
- `mov si, offset buffer + 2`: Устанавливаем индекс `si` на третий байт буфера (первые два байта содержат длину строки).
- `mov di, offset result`: Устанавливаем индекс `di` на начало буфера результата.
- `mov cx, 9`: Устанавливаем счетчик `cx` на 9 (максимальное число символов).
- Цикл `next_char`:
    - `lodsb`: Читает символ из `ds:si` в `al` и инкрементирует `si`.
    - `test si, 1`: Проверяет четность индекса `si`.
    - `jnz copy_char`: Если индекс нечетный, переходим к метке `copy_char`.
    - `loop next_char`: Переход к следующей итерации цикла.
- Метка `copy_char`:
    - `stosb`: Пишет символ из `al` в `es:di` и инкрементирует `di`.
    - `loop next_char`: Переход к следующей итерации цикла.
- Метка `done`: Конец процедуры.

### Основная процедура
```assembly
main proc
    ; подключаем data1, где расположен буфер, к ds
    mov ax, data1
    mov ds, ax

    call read_buffer

    ; подключаем data2, где расположен результат, к es
    mov ax, data2
    mov es, ax

    call copy_even_symbols

    ; подключаем data2, где расположен результат, к ds
    mov ax, data2
    mov ds, ax

    call print_result

    ; завершаем программу
    mov ah, 4Ch
    int 21h

    ret
main endp
```
Процедура `main` выполняет последовательность шагов для выполнения программы:
- `mov ax, data1`, `mov ds, ax`: Устанавливаем сегмент данных `data1` для `ds`.
- `call read_buffer`: Вызов процедуры ввода строки.
- `mov ax, data2`, `mov es, ax`: Устанавливаем сегмент данных `data2` для `es`.
- `call copy_even_symbols`: Вызов процедуры копирования символов.
- `mov ax, data2`, `mov ds, ax`: Устанавливаем сегмент данных `data2` для `ds`.
- `call print_result`: Вызов процедуры вывода строки.
- `mov ah, 4Ch`, `int 21h`: Завершение программы с кодом возврата 0.

### Конец программы
```assembly
code ENDS
end main
```
- Завершение сегмента кода и указание на стартовую процедуру `main`.

Таким образом, программа осуществляет ввод строки, копирование символов с четных позиций во второй сегмент и вывод результата на экран.

# Вопросы

## Почему именно доллар является символом конца строки? В Си, например, используется \0

В языке ассемблера MASM (Microsoft Macro Assembler) символ доллара '$' используется для обозначения конца строки, но не совсем так, как это делается в языке C, где символ '\0' используется как нулевой байт для указания конца строки. Чтобы понять, почему и как это работает, давайте рассмотрим несколько аспектов.

### Символ '$' в MASM

В MASM символ '$' не обозначает конец строки в самом её содержимом, а используется в директивах ассемблера и как метка текущей позиции. Например, если вы хотите вычислить длину строки, вы можете использовать '$' в выражении:

```asm
.data
myString db 'Hello, World!', 0

.code
mov dx, offset myString   ; Адрес начала строки
mov cx, $-myString        ; Длина строки
```

Здесь `$` обозначает текущую позицию в сегменте `.data`, а выражение `$-myString` вычисляет разницу между текущей позицией (которая находится сразу после строки) и началом строки, тем самым давая длину строки. Это полезно для таких операций, как инициализация длины строки или её обработка в других частях программы.

### Почему не '\0'?

В языке C строки заканчиваются символом `\0` (нулевой байт), что служит явным индикатором конца строки в памяти. Это сделано для удобства работы со строками в рантайме: функции библиотеки C, такие как `strlen`, `strcpy` и другие, используют этот символ для определения конца строки.

В ассемблере подход другой. Ассемблер предоставляет низкоуровневый контроль над памятью и кодом, и программист сам отвечает за организацию данных. Строки могут быть любыми байтовыми последовательностями, и использование нулевого байта для конца строки может быть нежелательным или даже невозможным в некоторых контекстах, например, когда строки содержат произвольные данные, включая нулевые байты.

### Работа с '$' и '\0' в MASM

Когда вы используете строки в MASM, вы можете сами выбирать, как организовать их концы. Например, если вы хотите, чтобы строки соответствовали стандарту C, вы можете вручную добавить нулевой байт в конец каждой строки:

```asm
.data
myString db 'Hello, World!', 0

.code
mov dx, offset myString
; Нужны дополнительные инструкции для поиска нулевого байта в строке,
; например, цикл, который ищет байт с значением 0.
```

С другой стороны, вы можете использовать символы длины строк или другие схемы для обработки строк.

Символ '$' в MASM не является символом конца строки в том смысле, как '\0' в языке C. Вместо этого он служит для вычисления текущей позиции в сегменте и для других полезных директив ассемблера. Для работы со строками программисты на ассемблере могут сами выбирать, использовать ли нулевой байт для обозначения конца строки или другую схему, в зависимости от требований задачи и удобства.

Давайте углубимся в детали использования символа '$' в MASM и разберём, почему он используется в функциях, таких как 9-я функция прерывания 21h, и как это связано с концепцией окончания строки.

### Использование '$' в прерывании 21h, функция 09h

В MS-DOS и соответствующем ассемблере MASM символ '$' имеет специальное значение, когда используется с функцией 09h прерывания 21h. Эта функция предназначена для вывода строки на стандартное устройство вывода (обычно консоль). Она считает строку оконченной, когда встречает символ '$'. Вот пример кода:

```asm
.data
msg db 'Hello, World!', 0dh, 0ah, '$'

.code
mov ah, 09h           ; Функция DOS для вывода строки
lea dx, msg           ; Указатель на строку
int 21h               ; Вызов прерывания DOS
```

### Причина использования '$'

Символ '$' выбран **по историческим причинам** и **особенностям реализации MS-DOS**. Он действует как специальный маркер конца строки для функции 09h прерывания 21h. Это означает, что когда функция встречает '$' в строке, она прекращает вывод. Если символ '$' не будет добавлен в конец строки, функция продолжит считывание и вывод байтов из памяти до тех пор, пока случайно не наткнётся на '$' или не произойдёт ошибка.

### Сравнение с '\0' в языке C

В языке C строки заканчиваются символом '\0' (нулевой байт), который является маркером конца строки для всех строковых операций, таких как `printf`, `strlen`, и т.д. Пример строки в C:

```c
char msg[] = "Hello, World!\n";
printf("%s", msg);
```

Здесь компилятор автоматически добавляет '\0' в конец строки.

### Примеры для иллюстрации

1. **MASM с '$'**:
    ```asm
    .data
    msg db 'Hello, World!', 0dh, 0ah, '$'  ; Строка заканчивается '$'

    .code
    mov ah, 09h           ; Функция DOS для вывода строки
    lea dx, msg           ; Указатель на строку
    int 21h               ; Вызов прерывания DOS
    ```

2. **C с '\0'**:
    ```c
    #include <stdio.h>

    int main() {
        char msg[] = "Hello, World!\n";  // Строка заканчивается '\0'
        printf("%s", msg);               // Функция C для вывода строки
        return 0;
    }
    ```

### Заключение

Символ '$' в MASM, используемый с функцией 09h прерывания 21h, служит аналогом '\0' в языке C, но это **НЕ универсальный конец строки** для всех строковых операций в ассемблере. Это специальная **договорённость для работы с функциями DOS**. В общем случае в ассемблере вы сами определяете, как строки организуются и каким образом их конец определяется, будь то нулевой байт, символ '$' или другая схема.

## Как работает команда test? Какие флаги меняются? Как дальше с этим работает jnz и какие еще есть варианты переходов? Для чего нужна метка done и переход к ней через jmp? Можно ли обойтись без нее, просто написав ret вместо jmp done? Разбор процедуры copy_even_symbols

Давайте разберем предложенную процедуру на языке ассемблера MASM детально, шаг за шагом, и поймем, как она работает.

### Комментарий к коду

#### Исходный код процедуры

```assembly
copy_even_symbols proc
    ; si - индекс в буфере, di - индекс в результирующей строке
    mov si, offset buffer + 2  ; в первых двух байтах ожидаемое и фактическое количества символов
    mov di, offset result

    ; будем перебирать не больше 9 символов
    mov cx, 9
    next_char:
        lodsb
        test si, 1
        jnz copy_char

        ; проходим по каждому символу
        loop next_char

        ; после цикла выходим
        jmp done

    copy_char:
        stosb
        loop next_char

    done:
        ret
copy_even_symbols endp
```

### Команда `test`

Команда `test` выполняет побитовую операцию "И" (AND) между двумя операндами и устанавливает флаги в регистре флагов на основе результата этой операции. В данном случае, команда `test si, 1` проверяет, является ли младший бит регистра `si` установленным (то есть нечетное ли значение в `si`).

Флаги, которые изменяет команда `test`:
- **ZF (Zero Flag)**: устанавливается, если результат операции равен нулю.
- **SF (Sign Flag)**: устанавливается, если результат отрицательный.
- **PF (Parity Flag)**: устанавливается, если количество единичных бит в результате четное.
- **OF (Overflow Flag)** и **CF (Carry Flag)** не изменяются.

### Команда `jnz`

Команда `jnz` (Jump if Not Zero) выполняет переход, если флаг нуля (ZF) не установлен. После команды `test si, 1`, флаг ZF будет установлен, если `si` четное (результат AND будет 0), и сброшен, если `si` нечетное (результат AND не будет 0).

### Другие варианты переходов

Другие команды условного перехода:
- **je / jz (Jump if Equal / Jump if Zero)**: переход, если ZF установлен.
- **jne / jnz (Jump if Not Equal / Jump if Not Zero)**: переход, если ZF не установлен.
- **jg / jnle (Jump if Greater / Jump if Not Less or Equal)**: переход, если результат больше нуля (SF = OF и ZF = 0).
- **jl / jnge (Jump if Less / Jump if Not Greater or Equal)**: переход, если результат меньше нуля (SF ≠ OF).
- **ja / jnbe (Jump if Above / Jump if Not Below or Equal)**: переход, если результат выше без знака (CF = 0 и ZF = 0).
- **jb / jnae (Jump if Below / Jump if Not Above or Equal)**: переход, если результат ниже без знака (CF = 1).

### Зачем нужна метка `done` и `jmp` к ней?

Метка `done` используется для обозначения конца процедуры. Команда `jmp done` выполняется после цикла `loop next_char`, чтобы выйти из процедуры, минуя выполнение кода в секции `copy_char`.

### Можно ли обойтись без метки `done`?

Да, можно обойтись без метки `done`, заменив команду `jmp done` на `ret`:

```assembly
copy_even_symbols proc
    ; si - индекс в буфере, di - индекс в результирующей строке
    mov si, offset buffer + 2  ; в первых двух байтах ожидаемое и фактическое количества символов
    mov di, offset result

    ; будем перебирать не больше 9 символов
    mov cx, 9
    next_char:
        lodsb
        test si, 1
        jnz copy_char

        ; проходим по каждому символу
        loop next_char

        ; после цикла выходим
        ret

    copy_char:
        stosb
        loop next_char

    ret
copy_even_symbols endp
```

### Общее объяснение работы процедуры

1. **Инициализация регистров**: `si` устанавливается на начало буфера, пропустив первые два байта, `di` устанавливается на начало результирующего массива.
2. **Инициализация счетчика**: `cx` устанавливается в 9.
3. **Цикл**:
    - `lodsb` загружает байт из `si` в `al` и увеличивает `si`.
    - `test si, 1` проверяет, нечетное ли значение в `si`.
    - Если нечетное (`jnz copy_char`), переходит к `copy_char`, где байт из `al` копируется в адрес `di`, и `di` увеличивается.
    - `loop next_char` уменьшает `cx` и, если не ноль, переходит на `next_char`.
4. **Завершение процедуры**: после выполнения цикла выполняется команда `ret`.

Таким образом, процедура копирует символы с нечетными индексами из буфера в результирующую строку.
